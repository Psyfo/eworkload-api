import mongoose from 'mongoose';
import bcrypt from 'bcrypt-nodejs';
import validator from 'validator';
import transporter from './../config/mail';
import AcademicAdministrationWorkload from './workload/academic-administration';
import CommunityInstructionWorkload from './workload/community-instruction';
import ExecutiveManagementWorkload from './workload/executive-management';
import FormalInstructionWorkload from './workload/formal-instruction';
import PersonnelDevelopmentWorkload from './workload/personnel-development';
import PublicServiceWorkload from './workload/public-service';
import ResearchWorkload from './workload/research';
import SupervisionWorkload from './workload/supervision';

const userSchema = new mongoose.Schema(
  {
    userId: {
      type: String,
      unique: true
    },
    password: {
      type: String
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      validate: value => {
        return validator.isEmail(value);
      }
    },
    firstName: {
      type: String
    },
    lastName: {
      type: String
    },
    photoUrl: {
      type: String
    },
    disciplineIds: [
      {
        type: String,
        ref: 'Discipline'
      }
    ],
    positionId: {
      type: String,
      ref: 'Position'
    },
    departmentId: {
      type: String,
      ref: 'Department'
    },
    gender: {
      type: String
    },
    nationality: {
      type: String
    },
    workFocusName: {
      type: String,
      default: 'Balanced',
      ref: 'WorkFocus'
    },
    createdAt: {
      type: Date
    },
    updatedAt: {
      type: Date
    }
  },
  {
    timestamps: true
  }
);

// VIRTUALS
userSchema.virtual('disciplines', {
  ref: 'Discipline',
  localField: 'disciplineIds',
  foreignField: 'disciplineId'
});
userSchema.virtual('position', {
  ref: 'Position',
  localField: 'positionId',
  foreignField: 'positionId',
  justOne: true
});
userSchema.virtual('workFocus', {
  ref: 'WorkFocus',
  localField: 'workFocusName',
  foreignField: 'name',
  justOne: true
});
userSchema.virtual('workFocus', {
  ref: 'WorkFocus',
  localField: 'workFocusName',
  foreignField: 'name',
  justOne: true
});
userSchema.virtual('department', {
  ref: 'Department',
  localField: 'departmentId',
  foreignField: 'departmentId',
  justOne: true
});
userSchema.virtual('full').get(function() {
  return (
    this.userId +
    '.' +
    this.email +
    '.' +
    this.firstName +
    '.' +
    this.lastName +
    '.' +
    this.photoUrl +
    '.' +
    this.workFocusName +
    '.' +
    this.disciplineId +
    '.' +
    this.positionId +
    '.' +
    this.gender +
    '.' +
    this.nationality
  );
});

// HOOKS
// Pre-hook to hash password. Make sure to use function and not arrow (lexical 'this' problem)
userSchema.pre('save', function(next) {
  const user = this;

  // Generate default Work Focus
  user.workFocusName = 'Balanced';

  // Generate password and mail it
  user.password = Math.random()
    .toString(36)
    .slice(-8);

  const mailOptions = {
    from: 'c4mahlangu@gmail.com', // sender address
    to: user.email, // list of receivers
    subject: 'Eworkload Credentials', // Subject line
    html: `<p>Welcome to the Eworkload system. Please find default credentials below</p> 
        <p>User ID: ${user.userId}</p>
        <p>Password: ${user.password}</p>
        <br>
        <p>Autogenerated password may be changed from the user profile at any time.</p>
        <p>Kind regards</p>
        <p>Administrator</p>` // plain text body
  };
  transporter.sendMail(mailOptions, function(err, info) {
    if (err) console.log(err);
    else console.log(info);
  });

  // Generate salt and hash password
  bcrypt.genSalt(10, (err, salt) => {
    bcrypt.hash(user.password, salt, null, (err, hash) => {
      if (err) throw err;
      user.password = hash;
    });
  });

  let initializeAAWorkload = async userId => {
    let aaWorkload = new AcademicAdministrationWorkload({
      userId: userId
    });
    return await aaWorkload.save();
  };
  let initializeCIWorkload = async userId => {
    let ciWorkload = new CommunityInstructionWorkload({
      userId: userId
    });
    return await ciWorkload.save();
  };
  let initializeEMWorkload = async userId => {
    let emWorkload = new ExecutiveManagementWorkload({
      userId: userId
    });
    return await emWorkload.save();
  };
  let initializeFIWorkload = async userId => {
    let fiWorkload = new FormalInstructionWorkload({
      userId: userId
    });

    return await fiWorkload.save();
  };
  let initializePDWorkload = async userId => {
    let pdWorkload = new PersonnelDevelopmentWorkload({
      userId: userId
    });
    return await pdWorkload.save();
  };
  let initializePSWorkload = async userId => {
    let psWorkload = new PublicServiceWorkload({
      userId: userId
    });
    return await psWorkload.save();
  };
  let initializeRWorkload = async userId => {
    let rWorkload = new ResearchWorkload({
      userId: userId
    });
    return await rWorkload.save();
  };
  let initializeSWorkload = async userId => {
    let sWorkload = new SupervisionWorkload({
      userId: userId
    });
    return await sWorkload.save();
  };
  initializeAAWorkload(user.userId);
  initializeCIWorkload(user.userId);
  initializeEMWorkload(user.userId);
  initializeFIWorkload(user.userId);
  initializePDWorkload(user.userId);
  initializePSWorkload(user.userId);
  initializeRWorkload(user.userId);
  initializeSWorkload(user.userId);

  // Indicates we're done and moves on to the next middleware
  next();
});

// INSTANCE METHODS
// Ensure correct password
userSchema.methods.isValidPassword = async password => {
  const user = this;

  // Hash sent password and compare with db hash
  const compare = await bcrypt.compare(password, user.password);
  return compare;
};

const User = mongoose.model('User', userSchema);
export default User;
